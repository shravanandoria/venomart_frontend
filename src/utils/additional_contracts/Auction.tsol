pragma ever-solidity >=0.61.2 ;

pragma AbiHeader expire;
pragma AbiHeader pubkey;
pragma AbiHeader time;

// Interfaces we needs
// This interface for transferring NFT to winner
import "@broxus/tip4/contracts/TIP4_1/interfaces/ITIP4_1NFT.tsol";
// This interface to accept NFT from owner
import "@broxus/tip4/contracts/TIP4_1/interfaces/INftTransfer.tsol";
// This interface for implementing tip-3 tokens receiving callback
import "@broxus/tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
// This interface for deploying TokenWallet
import "@broxus/tip3/contracts/interfaces/ITokenRoot.tsol";
// This interface to return lower bids
import "@broxus/tip3/contracts/interfaces/ITokenWallet.tsol";
import "@broxus/tip4/contracts/TIP4_1/interfaces/ITIP4_1NFT.tsol";
import "@broxus/tip4/contracts/TIP4_1/interfaces/INftChangeManager.tsol";
import "@broxus/tip4/contracts/access/OwnableInternal.tsol";

contract Auction is  IAcceptTokensTransferCallback {

    uint static nounce;
    address static factoryAuction;
    address static auction_owner;

    address platformOwner;

    uint128 platform_fee;
    
    uint32  public _startTime; // auction start time timestmp in seconds
    uint32  public _endTime; // auction end time timestamp in seconds

    address public _nft; // nft which will be sell
        
    uint128 public _currentBid; // state for holding current max bid
    uint128 public _base_nft_price; // state for holding current max bid
    address public _currentWinner; // current max bid owner
    
    address public _tokenRoot; // this token we will receive for bids
    address public _tokenWallet; // wallet for receive bids

    bool public _nftReceived; // is auction already receive nft
    bool public _closed; // action end flag

    uint128 bidding_gap;

    uint128 remain_on_contract = 0.3 ever;

    struct auction_info {
        address tokenRoot;
        address _tokenWallet;
        address nft;
        bool _nftReceived;
        bool _closed;
        uint128 _currentBid;
        uint128 _base_nft_price;
        address _currentWinner;        
        uint32 _startTime;
        uint32 _endTime; 
        uint test_now;
        uint128 amount;
        address current_winner;
    }

    struct test{
        bool _nftReceived;
        bool start_now;
        bool end_now;
        bool amount;
        bool _currentBid;
        address msg_sender;
        uint128 old_bid;
    }

    test demo;

    auction_info auction_data;

    constructor (
        uint128 _platform_fee,
        uint32 startTime,
        uint32 endTime,
        address tokenRoot,
        uint128 base_nft_price,
        address nft,
        uint128 _bidding_gap,
        address _platformOwner,
        address sendRemainingGasTo
    ) public {
        tvm.rawReserve(remain_on_contract, 0);
        platform_fee = _platform_fee;
        
        _closed = false;

        platformOwner = _platformOwner;
        
        _startTime = startTime;
        _endTime = endTime;

        _tokenRoot = tokenRoot;

        _base_nft_price = base_nft_price;

        _nft = nft;

        _nftReceived = true;

        bidding_gap = _bidding_gap;

        ITokenRoot(_tokenRoot).deployWallet {
            value: 0.2 ever,
            flag: 1,
            callback: Auction.onTokenWallet
        } (
            address(this),
            0.1 ever
        );
        
        auction_data = auction_info(
            _tokenRoot,
            address(0),
            _nft,
            true,
            false,
            0,
            _base_nft_price,
            address(0),
            _startTime,
            _endTime,
            0,
            0,
            address(0)
        );

        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });
    }

    function read_data() public view responsible returns (auction_info) {
        return {value: 0, bounce: false, flag: 64} (auction_data); 
    }

    function onTokenWallet(address value) external {
        require (
            msg.sender.value != 0 &&
            msg.sender == _tokenRoot,
            101
        );
        tvm.rawReserve(0.2 ever, 0);
        // just store our auction's wallet address for future interaction
        _tokenWallet = value;
        auction_data._tokenWallet = value;
        auction_owner.transfer({ value: 0, flag: 128, bounce: false });
    }

    function onAcceptTokensTransfer(
        address, // tokenRoot,
        uint128 amount,
        address sender,
        address, // senderWallet,
        address remainingGasTo,
        TvmCell payload
    ) override external {
        require (msg.value != 0 && msg.sender == _tokenWallet, 101);
        tvm.rawReserve(0.2 ever, 0);

        uint128 bid_gap_cal = _currentBid * bidding_gap / 1000 / 100; 
    
        if (
            _nftReceived      &&
            now >= _startTime &&
            now <= _endTime   &&
            amount >= _base_nft_price &&
            amount > _currentBid + bid_gap_cal
        ) {
            // bid updating
            uint128 oldBid = _currentBid;
            address oldWinner = _currentWinner;
            _currentBid = amount;
            _currentWinner = sender;

            auction_data.current_winner = _currentWinner;

            if (oldBid > 0) {
                // returning previous bid
                TvmCell empty;
                // REMEMBER that msg.sender is our TokenWallet! So we just call them to transfer back
                ITokenWallet(msg.sender).transfer{value: 0, flag: 128}(
                    oldBid,
                    oldWinner,
                    0,
                    remainingGasTo,
                    true,
                    empty
                );
            }
        } else {
            // if bid wasn't correct - we return it to sender
            // REMEMBER that msg.sender is our TokenWallet! So we just call them to transfer back
            ITokenWallet(msg.sender).transfer{value: 0, flag: 128}(
                amount,
                sender,
                0,
                remainingGasTo,
                true,
                payload
            );
        }
    }

    function finishAuction(
        address sendRemainingGasTo
    ) external {
        require(now >= _endTime, 102, "Auction is not over yet");
        require(msg.value >= 1 ever, 103);
        require(msg.sender == platformOwner, 103);
        // remember about gas management...and about gas constants libraries too :)
        
        if (_currentBid > 0) {
            // bid more than zero, so somebody has won! let's send NFT to winner
            _closed = true;
            mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;

            TvmCell empty;

            // do not forget to send bid amount for auction owner!
            ITokenWallet(_tokenWallet).transfer{value: 0.2 ever, flag: 0}(
                _currentBid,
                auction_owner,
                0.1 ever,
                address(this),
                true,
                empty
            );

            ITIP4_1NFT(_nft).transfer{
                value: 0,
                flag: 128 + 32,
                bounce: false
            }(
                _currentWinner,
                sendRemainingGasTo,
                noCallbacks
            );
        } else {
            _closed = true;
            // there is no bids, sad :(
            // returning NFT back to owner...may be next time :(
            mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;
            ITIP4_1NFT(_nft).changeManager{
                value: 0 ever,
                flag: 128 + 32,
                bounce: false
            }(
                auction_owner,
                sendRemainingGasTo,
                noCallbacks
            );
        }
    }
    
    function cancel_auction(address sendRemainingGasTo) external {
        require(msg.sender == auction_owner, 101, "You are not the owner of this auction");
        require(now >= _startTime && now <= _endTime, 102, "This auction is not live");

        TvmCell empty;
        mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;

        if(_currentWinner != address(0)){
            ITokenWallet(_tokenWallet).transfer{value: 0.2 ever, flag: 0}(
                _currentBid,
                _currentWinner,
                0,
                address(this),
                true,
                empty
            );
        }
    
        ITIP4_1NFT(_nft).changeManager{
            value: 0,
            flag: 128 + 32,
            bounce: false
        }(
            auction_owner,
            sendRemainingGasTo,
            noCallbacks
        );
    }

}