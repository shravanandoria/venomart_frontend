pragma ever-solidity >=0.61.2 ;

pragma AbiHeader expire;
pragma AbiHeader pubkey;
pragma AbiHeader time;

// Interfaces we needs
// This interface for transferring NFT to winner
import "@broxus/tip4/contracts/TIP4_1/interfaces/ITIP4_1NFT.tsol";
// This interface to accept NFT from owner
import "@broxus/tip4/contracts/TIP4_1/interfaces/INftTransfer.tsol";
import "@broxus/tip4/contracts/TIP4_1/interfaces/INftChangeManager.tsol";
// This interface for implementing tip-3 tokens receiving callback
import "@broxus/tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "@broxus/tip4/contracts/access/OwnableInternal.tsol";

import "locklift/src/console.tsol";
import "./Auction.tsol";

contract FactoryAuction is  INftChangeManager, OwnableInternal {

    uint256 static _nounce; // random nonce for affecting on address

    TvmCell auctionCode;
    address _owner;
    uint128 platformFee;
    uint128 listing_fee;

    address[] auctions;

    event TokenCancelStatus(bool status);

    constructor (
        address sendRemainingGasTo,
        uint128 _listing_fee,
        uint128 _platform_fee,
        address owner_,
        TvmCell _auctionCode
    ) public OwnableInternal(_owner) {
        tvm.accept();
        tvm.rawReserve(2 ever, 0);

        _owner = owner_;
        auctionCode = _auctionCode;
        platformFee = _platform_fee;
        listing_fee = _listing_fee;

        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });
    }

    function read_code() public view responsible returns (address[]) {
        return {value: 0, bounce: false, flag: 64} (auctions); 
    }

    function onNftChangeManager(
        uint256 id,
        address owner,
        address oldManager,
        address newManager,
        address collection,
        address sendGasTo,
        TvmCell payload
    ) override external {
        tvm.rawReserve(0.2 ever, 4);
        (uint32 startTime, uint32 endTime, uint128 base_nft_price, address tokenRoot, uint128 bidding_gap) = abi.decode(payload, (uint32, uint32, uint128, address, uint128));

        TvmCell _stateInit = tvm.buildStateInit({
            code: auctionCode,
            contr: Auction,
            varInit: {
                nounce: tx.timestamp,
                factoryAuction: address(this),
                auction_owner: owner         
            }
        });

        address auction = new Auction{
            stateInit: _stateInit,
            value: 1 ever,
            flag: 1
        } (
            platformFee,
            startTime,
            endTime,
            tokenRoot,
            base_nft_price,
            msg.sender,
            bidding_gap,
            _owner,
            sendGasTo
        );

        auctions.push(auction);

        mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;

        ITIP4_1NFT(msg.sender).changeManager{
            value: 0,
            flag: 128,            
            bounce: false
        } (
            auction,
            sendGasTo,
            noCallbacks
        );
    }

    function cancel_listing(address nftAddress) external {

        mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;

        ITIP4_1NFT(nftAddress).changeManager {
            value: 0,
            flag: 128 ,
            bounce: false
        } (
            msg.sender,
            address(this),
            noCallbacks
        );

        emit TokenCancelStatus(true);
    }

    function generatePayload(uint32 startTime, uint32 endTime, uint128 base_nft_price, address tokenRoot, uint128 bidding_gap ) external view
		virtual
		responsible
		returns (
			TvmCell payload
		) {
            require(base_nft_price > 0, 101);
            TvmBuilder payloadBuilder;
            payloadBuilder.store(startTime, endTime, base_nft_price, tokenRoot, bidding_gap);

            return {value: 0, bounce: false, flag: 64} (
                payloadBuilder.toCell()
            );
    }
    
}