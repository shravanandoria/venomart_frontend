pragma ever-solidity >=0.61.2 ;

pragma AbiHeader expire;
pragma AbiHeader time;
pragma AbiHeader pubkey;

import "@broxus/tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "@broxus/tip3/contracts/interfaces/ITokenRoot.tsol";
import "@broxus/tip3/contracts/interfaces/ITokenWallet.tsol";

import "@broxus/tip4/contracts/access/OwnableInternal.tsol";

import "./MakeOffer.tsol";
import "locklift/src/console.tsol";

contract FactoryMakeOffer is OwnableInternal, IAcceptTokensTransferCallback {

    uint256 static _nonce;
    address public _tokenWallet;
    address public _tokenRoot;
    
    address _owner;
    
    uint128 public listing_commission;
    uint128 public platform_fees;
    // reserve on contract, 0.5 to deploy child contract & reserve there, 0.2 = transferring WVENOMS to child contract, 0.1 = for safety
    uint128 public remainOnContract = 0.2 ever;
    uint128 public deployMakeOffer_cost = 0.5 ever;
    uint128 public transfer_WVENOM_makeOffer_cost = 0.2 ever;
    uint128 public oldOffer_refund_cost= 0.01 ever;
    
    TvmCell makeOfferCode;

    address[] openOffers;

    struct offerInfo {
        address nft_address;
        uint128 offer_amount;
        uint128 validity;
        address old_offer;
    }

    offerInfo info;

    event new_offer(
        address offerrer,
        address nft_address,
        address new_offer_contract,
        uint128 offer_amount,
        uint128 validity
    );

    constructor(
        address sendRemainingGasTo,
        uint128 _platform_fees,
        address owner,
        TvmCell _makeOfferCode,
        address tokenRoot
    )   public 
        OwnableInternal(owner) {
        
        require(tvm.pubkey() != 0, 101);
        require(tvm.pubkey() == msg.pubkey(), 102);

        tvm.accept();
        tvm.rawReserve(remainOnContract, 0);
        
        _owner = owner;
        platform_fees = _platform_fees;
        makeOfferCode = _makeOfferCode;

        _tokenRoot = tokenRoot;

        ITokenRoot(_tokenRoot).deployWallet {
            value: 0.2 ever,
            flag: 1,
            callback: FactoryMakeOffer.onTokenWallet
        } (
            address(this),
            0.1 ever
        );

        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });
    }

    function onTokenWallet(address value) external {
        require (
            msg.value != 0 &&
            msg.sender == _tokenRoot,
            101
        );
        tvm.rawReserve(remainOnContract, 0);

        _tokenWallet = value;
        _owner.transfer({ value: 0, flag: 128, bounce: false });
    }
    
    function makeOffer_fee() public view responsible returns (uint128) {
        uint128 fee = remainOnContract + oldOffer_refund_cost + deployMakeOffer_cost + transfer_WVENOM_makeOffer_cost;
        return {value: 0, bounce: false, flag: 64} (fee);
    }

    function onAcceptTokensTransfer(
        address, // tokenRoot,
        uint128 amount,
        address sender,
        address, // senderWallet,
        address remainingGasTo,
        TvmCell payload
    ) override external {
        require(amount > 0, 101);
        require (msg.value != 0 && msg.sender == _tokenWallet, 101);

        require(msg.value > remainOnContract + oldOffer_refund_cost + deployMakeOffer_cost + transfer_WVENOM_makeOffer_cost, 101, "Please send sufficient amount");

        tvm.rawReserve(remainOnContract, 0); // 0.2 ever

        (address nft_address, address old_offer, uint128 validity) = abi.decode(payload, (address, address, uint128));

        if(old_offer != address(0)) {
            MakeOffer(old_offer).refund_old_offer{value: 0.01 ever}(amount);
            info.old_offer = old_offer;
        }
        
        info.nft_address = nft_address;
        info.offer_amount = amount;
        info.validity = validity;

        TvmCell _stateInit = tvm.buildStateInit({
            code: makeOfferCode,
            contr: MakeOffer,
            varInit: {
                nonce: tx.timestamp,
                contract_creator: address(this),
                platform_owner: _owner,
                _tokenRoot: _tokenRoot,
                offer_owner: sender        
            }
        });

        address makeOffer = new MakeOffer {
            stateInit: _stateInit,
            value: deployMakeOffer_cost, //0.5 ever
            flag: 1
        } (
            remainingGasTo,
            validity,
            platform_fees,
            nft_address
        );

        TvmCell empty;

        openOffers.push(makeOffer);

        emit new_offer (
            sender,
            nft_address,
            makeOffer,
            amount,
            validity
        );

        // ITokenWallet(_tokenWallet).transfer{value: 0, flag: 0}(
        ITokenWallet(_tokenWallet).transfer{value: transfer_WVENOM_makeOffer_cost, flag: 1}(
            amount,
            makeOffer,
            0.1 ever,
            sender,
            true,
            empty
        );

        sender.transfer({ value: 0, flag: 128, bounce: false });
    }

    function read_code() public view responsible returns (address[], offerInfo) {
        return {value: 0, bounce: false, flag: 64} (openOffers, info); 
    }

    function update_platform_fees(uint128 _platform_fees) public onlyOwner{
        platform_fees = _platform_fees;
    }

    function cancel_listing(address nftAddress) external {

        mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;

        ITIP4_1NFT(nftAddress).changeManager {
            value: 0,
            flag: 128 ,
            bounce: false
        } (
            msg.sender,
            address(this),
            noCallbacks
        );

    }
}