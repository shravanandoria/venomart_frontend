pragma ever-solidity >=0.61.2 ;

pragma AbiHeader expire;
pragma AbiHeader time;
pragma AbiHeader pubkey;

import "@broxus/tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "@broxus/tip3/contracts/interfaces/ITokenRoot.tsol";
import "@broxus/tip3/contracts/interfaces/ITokenWallet.tsol";

import "@broxus/tip4/contracts/access/OwnableInternal.tsol";

import "./MakeOffer.tsol";
import "locklift/src/console.tsol";

contract FactoryMakeOffer is OwnableInternal, IAcceptTokensTransferCallback {

    uint256 static _nonce;
    address public _tokenWallet;
    address public _tokenRoot;
    
    
    uint128 public listing_commission;
    uint128 public platform_fees;
    // reserve on contract, 0.5 to deploy child contract & reserve there, 0.2 = transferring WVENOMS to child contract, 0.1 = for safety
    uint128 public remainOnContract = 0.2 ever;
    uint128 public deployMakeOffer_cost = 0.6 ever;
    uint128 public transfer_WVENOM_makeOffer_cost = 0.2 ever;
    uint128 public oldOffer_refund_cost= 0.01 ever;
    
    TvmCell makeOfferCode;

    event new_offer(
        address offerrer,
        address nft_address,
        address new_offer_contract,
        uint128 offer_amount,
        uint128 validity
    );

    constructor(
        address sendRemainingGasTo,
        uint128 _platform_fees,
        address owner,
        TvmCell _makeOfferCode,
        address tokenRoot
    )   public 
        OwnableInternal(owner) {
        
        require(tvm.pubkey() != 0, 101);
        require(tvm.pubkey() == msg.pubkey(), 102);

        tvm.accept();
        tvm.rawReserve(remainOnContract, 0);
        
        platform_fees = _platform_fees;
        makeOfferCode = _makeOfferCode;

        _tokenRoot = tokenRoot;

        ITokenRoot(_tokenRoot).deployWallet {
            value: 0.2 ever,
            flag: 1,
            callback: FactoryMakeOffer.onTokenWallet
        } (
            address(this),
            0.1 ever
        );

        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });
    }

    function onTokenWallet(address value) external {
        require (
            msg.value != 0 &&
            msg.sender == _tokenRoot,
            101
        );
        tvm.rawReserve(remainOnContract, 0);

        _tokenWallet = value;
        owner().transfer({ value: 0, flag: 128, bounce: false });
    }

    function makeOffer_fee() public view responsible returns (uint128) {
        uint128 refundable_fee = 0.1 ever;
        uint128 fee = remainOnContract + oldOffer_refund_cost + deployMakeOffer_cost + transfer_WVENOM_makeOffer_cost + refundable_fee;
        return {value: 0, bounce: false, flag: 64} (fee);
    }

    function onAcceptTokensTransfer(
        address, // tokenRoot,
        uint128 amount,
        address sender,
        address, // senderWallet,
        address remainingGasTo,
        TvmCell payload
    ) override external {
        require(amount > 0, 101);
        require (msg.value != 0 && msg.sender == _tokenWallet, 101);

        require(msg.value > remainOnContract + oldOffer_refund_cost + deployMakeOffer_cost + transfer_WVENOM_makeOffer_cost, 101, "Please send sufficient amount");

        tvm.rawReserve(remainOnContract, 0); // 0.2 ever

        (address nft_address, address old_offer, uint128 validity) = abi.decode(payload, (address, address, uint128));

        if(old_offer != address(0)) {
            MakeOffer(old_offer).return_offer{value: 0.01 ever}();
        }
        
        TvmCell _stateInit = tvm.buildStateInit({
            code: makeOfferCode,
            contr: MakeOffer,
            varInit: {
                nonce: tx.timestamp,
                contract_creator: address(this),
                platform_owner: owner(),
                _tokenRoot: _tokenRoot,
                offer_owner: sender        
            }
        });

        address makeOffer = new MakeOffer {
            stateInit: _stateInit,
            value: deployMakeOffer_cost, //0.5 ever
            flag: 1
        } (
            remainingGasTo,
            validity,
            platform_fees,
            nft_address
        );

        TvmCell empty;

        emit new_offer (
            sender,
            nft_address,
            makeOffer,
            amount,
            validity
        );
    
        ITokenWallet(_tokenWallet).transfer{value: transfer_WVENOM_makeOffer_cost, flag: 1}(
            amount,
            makeOffer,
            0.1 ever,
            sender,
            true,
            empty
        );

        sender.transfer({ value: 0, flag: 128, bounce: false });
    }

    function update_allCosts(
        uint128 _remainOnContract,
        uint128 _deployMakeOffer_cost,
        uint128 _transfer_WVENOM_makeOffer_cost,
        uint128 _oldOffer_refund_cost
    ) public onlyOwner {
        remainOnContract = _remainOnContract;
        deployMakeOffer_cost = _deployMakeOffer_cost;
        transfer_WVENOM_makeOffer_cost = _transfer_WVENOM_makeOffer_cost;
        oldOffer_refund_cost = _oldOffer_refund_cost;
    }

    function update_makeOfferCode(TvmCell new_makeOffer) public onlyOwner {
        makeOfferCode = new_makeOffer;
    }
}