pragma ever-solidity >= 0.61.2;

pragma AbiHeader expire;
pragma AbiHeader time;
pragma AbiHeader pubkey;

// Interfaces we needs
// This interface for transferring NFT to winner
import "@broxus/tip4/contracts/TIP4_1/interfaces/ITIP4_1NFT.tsol";
// This interface to accept NFT from owner
import "@broxus/tip4/contracts/TIP4_1/interfaces/INftTransfer.tsol";
import "@broxus/tip4/contracts/TIP4_1/interfaces/INftChangeManager.tsol";
// This interface for implementing tip-3 tokens receiving callback
import "@broxus/tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "@broxus/tip4/contracts/access/OwnableInternal.tsol";

contract Marketplace is  INftChangeManager, OwnableInternal {

    uint256 static _nonce; // random nonce for affecting on address
    // address _owner; // owner of auction and nft
    
    address public _tokenWallet; // wallet for receive bids
    address _owner; 
    
    uint128 private _nftId;
    
    uint128 private listing_commission;
    uint128 private platform_fees;

    struct ListedToken {
        uint128 nftId;
        address nft_address;
        address owner;
        address manager;
        uint128 price;
        bool currentlyListed;
    }

    event TokenListedSuccess(
        uint128 nftId,
        address nft_address,
        address owner,
        address manager,
        uint128 price,
        bool currentlyListed
    );

    event TokenCancelStatus(
        bool status
    );

    event TokenSaleStatus(
        bool status
    );


    mapping(uint128 => ListedToken) public id_listed_token;
    mapping(address => ListedToken) public address_listed_token;

    constructor(
        address sendRemainingGasTo,
        uint128 _listing_commission,
        uint128 _platform_fees,
        address owner
    )   public
        OwnableInternal(owner){
        tvm.accept();
        tvm.rawReserve(1 ever, 0);

      _owner = owner;
      sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });
      listing_commission = _listing_commission;
      platform_fees = _platform_fees;
    }

    function onNftChangeManager(
        uint256 id,
        address owner,
        address oldManager,
        address newManager,
        address collection,
        address sendGasTo,
        TvmCell payload
    ) override external {
        uint128 price = abi.decode(payload, (uint128));

        if(msg.value < listing_commission){
            owner.transfer({ value: msg.value, flag: 0, bounce: false });
        } else{
            tvm.rawReserve( listing_commission, 0);

            uint128 nftId = _nftId;
            ListedToken newToken = ListedToken(
                nftId,
                msg.sender,
                owner,
                newManager,
                price,
                true
            );

            id_listed_token[nftId] = newToken;
            address_listed_token[msg.sender] = newToken;
            _nftId++;

            emit TokenListedSuccess(
                nftId,
                msg.sender,
                owner,
                newManager,
                price,
                true
            );

        }
    }

    function generatePayload(uint128 price) external view
		virtual
		responsible
		returns (
			TvmCell payload
		){
            require(price > 0, 101);
            TvmBuilder payloadBuilder;
            payloadBuilder.store(price);

            return {value: 0, bounce: false, flag: 64} (
				payloadBuilder.toCell()
			);
    }

    function check_fees(
        address nft_address,
        uint128 royalty,
        address royalty_address
    ) public view responsible returns(uint128){
        ListedToken nft = address_listed_token[nft_address];
        uint128 price = nft.price;
        uint128 platform_fees_ = (price * (platform_fees / 1000)) / 100;

        return {value: 0, bounce: false, flag: 64} (platform_fees_);
    }

    function buyNft(
        address sendRemainingGasTo,
        address nft_address,
        uint128 royalty,
        address royalty_address
    ) public {
        
        ListedToken nft = address_listed_token[nft_address];
        uint128 price = nft.price;

        // require(msg.value < price, 101);

        uint128 platform_fees_ = ((price) * (platform_fees / 1000)) / 100;
        
        if (msg.value < (price)) {
            msg.sender.transfer(msg.value, false, 0);
            emit TokenSaleStatus(false);
        } else {
            tvm.rawReserve(platform_fees_, 0);

            mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;
            
            nft.owner.transfer(price, false, 0);    

            if(address(royalty_address) != address(0)){
                royalty_address.transfer(royalty, false, 0);
            }

            ITIP4_1NFT(nft.nft_address).transfer{
                value: 0,
                flag: 128,
                bounce: false
            }(
                msg.sender,
                sendRemainingGasTo,
                noCallbacks
            );

            nft.owner = msg.sender;
            nft.manager = msg.sender;
            nft.price = 0;
            nft.currentlyListed = false;

            address_listed_token.replace(nft_address, nft);
            emit TokenSaleStatus(true);
        }
    }

    function update_listing_fees(uint128 _listing_commission) public onlyOwner{
        listing_commission = _listing_commission;
    }

    function update_platform_fees(uint128 _platform_fees) public onlyOwner{
        platform_fees = _platform_fees;
    }

    function get_nftId() public view responsible returns (uint){
        return { value: 0, flag: 64, bounce: false } ( _nftId);
    }

    function getAllNFTs() public view responsible returns (ListedToken[]) {
        uint128 nftCount = _nftId;
        ListedToken[] nfts = new ListedToken[](nftCount);
        uint128 currentIndex = 0;
        for(uint128 i = 0; i < nftCount; i++){
            if(id_listed_token[i].owner != address(0)){
                ListedToken currentToken = id_listed_token[i];
                nfts[currentIndex] = currentToken;
                currentIndex++;
            }
        }
        return { value: 0, flag: 64, bounce: false }  (nfts);
    }

    function get_nft_by_address (address nft_address) public view responsible returns (ListedToken) {
        ListedToken token = address_listed_token[nft_address];
        return { value: 0, flag: 64, bounce: false } (token);
    }
    
    function withdraw(address receipient, uint128 value) public onlyOwner{
        tvm.accept();
        receipient.transfer(value, true);
    }

    function cancel_listing(address nft_address) public {
        ListedToken nft = address_listed_token[nft_address];
        require(msg.sender == nft.owner, 101);
        require(nft.currentlyListed, 101);

        mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;

        ITIP4_1NFT(nft_address).changeManager{
            value: 0,
            flag: 128,
            bounce: false
        }(
            msg.sender,
            msg.sender,
            noCallbacks
        );

        nft.owner = msg.sender;
        nft.manager = msg.sender;
        nft.price = 0;
        nft.currentlyListed = false;
        address_listed_token.replace(nft_address, nft);
        msg.sender.transfer(listing_commission, false, 0);
        emit TokenCancelStatus(true);
    }
}