pragma ever-solidity >=0.61.2 ;

pragma AbiHeader expire;
pragma AbiHeader pubkey;
pragma AbiHeader time;

// import "@broxus/tip3/contracts/interfaces/IAcceptTokensTransferCallback.sol";
import "@broxus/tip4/contracts/TIP4_1/interfaces/ITIP4_1NFT.tsol";


contract DirectSell {

    uint static nonce;

    address static factoryDirectSell;       // address of the contract which deployed this contract
    address static owner;                   // platform owner
    address static nftAddress;              // address of NFT
    address static nft_owner;               // nft owner
    address static _platform_fees_address;  // address to receive platform fee

    uint128 price; // NFT Price
    uint128 platform_fee; // V0.1
    uint128 royalty; // in percentage
    address royalty_address; 
    
    uint128 remainOnContract = 0.1 ever;
    
    event NFT_Listed(
        address nft_address,
        address nft_owner,
        uint128 nft_price,
        uint128 royalty_percent,
        address royalty_address,
        address platform_owner,
        uint128 platform_fee,
        address factory_address
    );
    
    constructor(
        uint128 _price,
        uint128 _platform_fee,
        uint128 _royalty,
        address _royalty_address
    ) public {

        require(msg.sender == factoryDirectSell, 101);
        require(msg.value > remainOnContract, 101, "Please Send Correct Amount");

        tvm.rawReserve(remainOnContract, 0);

        price = _price; 
        platform_fee = _platform_fee;
        royalty = _royalty;
        royalty_address = _royalty_address;

        emit NFT_Listed(
            nftAddress,
            nft_owner,
            price,
            royalty,
            royalty_address,
            owner,
            platform_fee,
            factoryDirectSell                
        );

        nft_owner.transfer({ value: 0, flag: 128, bounce: false });
    }


    // returns total NFT price including nft price, platform fee & royalty. 
    function get_nft_price() public view responsible returns (uint128) {  
        uint128 platform_fees_ = price * platform_fee / 1000 / 100;
        uint128 royalty_ = price * royalty / 1000 / 100;
        uint128 total_nft_price = price + platform_fees_ + royalty_;
        return {value: 0, bounce: false, flag: 64} (total_nft_price);
    }

    // returns information of listed nft
    function get_listing_data() public view responsible returns (address, address, address, address, address, uint128, uint128, uint128 ){
        return {value: 0, bounce: false, flag: 64} 
        (factoryDirectSell, owner, nftAddress, nft_owner, royalty_address, price, platform_fee, royalty);
    }

    // if user cancels nft listing nft gets returned to nft owner & this contract gets destroyed
    function cancel_listing() external {
        require(msg.sender == nft_owner, 101, "You are not the owner of this nft");

        mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;

        ITIP4_1NFT(nftAddress).changeManager {
            value: 0,
            flag: 128 + 32,
            bounce: false
        } (
            msg.sender,
            address(this),
            noCallbacks
        );
    }

    // function to purchase NFT, when successfully purchased this contract gets destroyed
    function buyNft (
        address new_nft_holder
    ) public {
        
        uint128 platform_fees_ = price * platform_fee / 1000 / 100;
        uint128 royalty_ = price * royalty / 1000 / 100;

        // if user send wrong amount then returning user's wrong amount back
        // reason of not using require is sometimes user does bulk buy of nfts in that case
        // factory contract calls this function & if wrong amount sent, the amount is refunded to
        // factory contract instead of actual user.

        if(msg.value > price + platform_fees_ + royalty_) { 
            // require(msg.value >= price + platform_fees_ + royalty_ , 101, "Please Send Sufficient Amount");
            require(new_nft_holder != address(0), 101, "New NFT holder address is not correct");

            //sending fee to platform owner
            _platform_fees_address.transfer(platform_fees_, false, 0);

            //sending nft price & remain on contract to creator
            nft_owner.transfer(price + remainOnContract, false, 0);

            //sending nft royalty to royalty address
            if(royalty_ > 0 && royalty_address != address(0)){
                royalty_address.transfer(royalty_, false, 0);
            }

            mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;

            ITIP4_1NFT(nftAddress).transfer{ // sucessfully transferring NFT to buyer
                value: 0,
                flag: 128 + 32,
                bounce: false
            } (
                new_nft_holder,
                new_nft_holder,
                noCallbacks
            );
        } else {
            new_nft_holder.transfer(msg.value - 0.1 ever, false, 0); // returning wrong amount to user who sent it
        }
    }
}